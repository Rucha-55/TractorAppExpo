import { MaterialIcons } from '@expo/vector-icons';
import * as Font from 'expo-font';
import { Image as ExpoImage } from 'expo-image';
import * as Notifications from 'expo-notifications';
import { useLocalSearchParams, useRouter } from 'expo-router';
import { addDoc, collection, deleteDoc, doc, getDoc, getDocs, increment, query, serverTimestamp, setDoc, where } from 'firebase/firestore';
import { useEffect, useRef, useState } from 'react';
import {
  Alert,
  Animated,
  AppState,
  Dimensions,
  Image,
  KeyboardAvoidingView,
  Modal,
  Platform,
  SafeAreaView,
  ScrollView,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View
} from 'react-native';
import { db } from '../config/firebase';
import mdojoFullFlow from './mdojo_full_flow.json';
import { matchStepFromText } from '../utils/stepMatcher';

const { width, height } = Dimensions.get('window');

// Custom component to render text with larger emojis
const EmojiText = ({ children, style, emojiSize = 24 }) => {
  // Regex to match emoji characters
  const emojiRegex = /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/u;
  
  if (typeof children !== 'string') {
    return <Text style={style}>{children}</Text>;
  }
  
  const parts = children.split(/([\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}])/u);
  
  return (
    <Text style={[style, { 
      lineHeight: emojiSize + 12,
      includeFontPadding: false,
      textAlignVertical: 'center'
    }]}>
      {parts.map((part, index) => {
        if (emojiRegex.test(part)) {
          return (
            <Text key={index} style={[style, { 
              fontSize: emojiSize,
              lineHeight: emojiSize + 8,
              includeFontPadding: false,
              textAlignVertical: 'center',
              marginTop: Platform.OS === 'android' ? -2 : 0,
              marginBottom: Platform.OS === 'android' ? -2 : 0,
            }]}>
              {part}
            </Text>
          );
        }
        return part;
      })}
    </Text>
  );
};

const CHAT_STATES = {
  MOOD_SELECTION: 'MOOD_SELECTION',
  FOLLOW_UP: 'FOLLOW_UP',
  SECONDARY_QUESTION: 'SECONDARY_QUESTION',
  THIRD_QUESTION: 'THIRD_QUESTION',
  FOURTH_QUESTION: 'FOURTH_QUESTION',
  ELABORATION: 'ELABORATION',
  FINAL_MESSAGE: 'FINAL_MESSAGE',
  THANK_YOU: 'THANK_YOU'
};

const MOODS = [
  { id: 'glad', label: 'Glad!', gif: require('../assets/images/glad.gif'), color: '#E31937' },
  { id: 'sad', label: 'Sad!', gif: require('../assets/images/sad.gif'), color: '#E31937' },
  { id: 'mad', label: 'Mad!', gif: require('../assets/images/mad.gif'), color: '#E31937' }
];

export async function scheduleFeedbackReminder() {
  if (Platform.OS === 'ios' || Platform.OS === 'android') {
    // Cancel any existing notifications
    await Notifications.cancelAllScheduledNotificationsAsync();

    // Set the notification to trigger between 5-6 days from now
    const daysToAdd = 5 + Math.floor(Math.random() * 2); // 5 or 6 days
    const trigger = new Date();
    trigger.setDate(trigger.getDate() + daysToAdd);

    // Schedule the notification
    await Notifications.scheduleNotificationAsync({
      content: {
        title: "We'd love your feedback! 💬",
        body: "How has your experience been with our app? Tap to share your thoughts!",
        data: { type: 'feedback-reminder' },
      },
      trigger: {
        date: trigger,
      },
    });

    console.log(`Scheduled feedback reminder for ${daysToAdd} days from now.`);
  } else {
    // On web, do nothing (or log if you want)
    console.log('Notifications are not supported on web.');
  }
}

const ChatScreen = () => {
  const { employeeId: loggedInEmployeeId, employeeName } = useLocalSearchParams();
  const [isTyping, setIsTyping] = useState(false);
  const [message, setMessage] = useState('');
  const [messages, setMessages] = useState([]);
  const [chatState, setChatState] = useState(CHAT_STATES.MOOD_SELECTION);
  const [selectedMood, setSelectedMood] = useState(null);
  const [selectedOption, setSelectedOption] = useState(null);
  const [selectedSecondaryOption, setSelectedSecondaryOption] = useState(null);
  const [currentFlow, setCurrentFlow] = useState(null); // Glad/Sad/Mad object from JSON
  const [currentStep, setCurrentStep] = useState(null); // e.g., 'step1', 'step2_task'
  const [elaboration, setElaboration] = useState('');
  const [showOptions, setShowOptions] = useState(false);
  const [showSecondaryOptions, setShowSecondaryOptions] = useState(false);
  const scrollViewRef = useRef(null);
  const fadeAnim = useState(new Animated.Value(0))[0];
  const followUpScrollRef = useRef(null);

  const secondaryScrollRef = useRef(null);
  const [selectedThirdOption, setSelectedThirdOption] = useState(null);
  const [selectedFourthOption, setSelectedFourthOption] = useState(null);
  const [showThirdOptions, setShowThirdOptions] = useState(false);
  const [showFourthOptions, setShowFourthOptions] = useState(false);
  const [userName, setUserName] = useState('');

  const thirdScrollRef = useRef(null);
  const fourthScrollRef = useRef(null);
  const editTextInputRef = useRef(null);
  const [editText, setEditText] = useState('');
  const [showEditText, setShowEditText] = useState(false);
  const [editTextPlaceholder, setEditTextPlaceholder] = useState('');
  const [pendingNextStep, setPendingNextStep] = useState(null);
  const [pendingMessages, setPendingMessages] = useState([]);
  const [sadReasonKey, setSadReasonKey] = useState(null);
  const [madReasonKey, setMadReasonKey] = useState(null);
  const [conversationResponses, setConversationResponses] = useState([]);
  const [showEndPopup, setShowEndPopup] = useState(false);
  const router = useRouter();
  const [qaPairs, setQaPairs] = useState([]);
  const [visibleOptions, setVisibleOptions] = useState([]);
  const [showOptionsSequentially, setShowOptionsSequentially] = useState(false);
  const [showThinkingDots, setShowThinkingDots] = useState(false);
  const [showVideo, setShowVideo] = useState(true);
  const [gifLoadError, setGifLoadError] = useState(false);
  const [gifLoading, setGifLoading] = useState(true);
  const [useExpoImage, setUseExpoImage] = useState(true);
  const [gifAnimationEnabled, setGifAnimationEnabled] = useState(true);
  const [gifRefreshKey, setGifRefreshKey] = useState(0);

  // Inactivity timer states
  const [showInactivityPrompt, setShowInactivityPrompt] = useState(false);
  const inactivityTimerRef = useRef(null);
  const inactivityPromptRef = useRef(null);
  const [isChatFullyLoaded, setIsChatFullyLoaded] = useState(false);
  const [fontsLoaded, setFontsLoaded] = useState(false);

  const normalizeKey = (str) => str.toLowerCase().replace(/[^a-z0-9]+/g, '_');

  // Function to strip emojis from text for key generation
  const stripEmojis = (str) => {
    // Remove invisible characters, zero-width spaces, and other problematic characters first
    let cleaned = str.replace(/[\u200B-\u200D\uFEFF]/g, ''); // Remove zero-width characters
    cleaned = cleaned.replace(/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, ''); // Remove emojis
    return cleaned.trim();
  };

  // Function to normalize key from text with emojis
  const normalizeKeyFromEmojiText = (str) => {
    console.log('[DEBUG] Original option text:', str);
    const strippedText = stripEmojis(str);
    console.log('[DEBUG] Stripped text:', strippedText);
    const normalizedKey = normalizeKey(strippedText);
    console.log('[DEBUG] Normalized key:', normalizedKey);
    return normalizedKey;
  };

  // Function to start inactivity timer
  const startInactivityTimer = () => {
    // Don't start timer if chat is completed
    if (chatState === CHAT_STATES.THANK_YOU) {
      console.log('[INACTIVITY] Not starting timer - chat completed:', { chatState, platform: Platform.OS });
      return;
    }
    
    // Set chat as fully loaded if not already
    if (!isChatFullyLoaded) {
      setIsChatFullyLoaded(true);
    }
    
    console.log('[INACTIVITY] Starting inactivity timer for 20 seconds on', Platform.OS, { chatState, isChatFullyLoaded });
    
    // Clear existing timer
    if (inactivityTimerRef.current) {
      clearTimeout(inactivityTimerRef.current);
    }
    
    // Clear existing prompt
    if (inactivityPromptRef.current) {
      clearTimeout(inactivityPromptRef.current);
    }
    
    setShowInactivityPrompt(false);
    
    // Start new timer for 20 seconds (change this value to adjust the timer)
    inactivityTimerRef.current = setTimeout(() => {
      // Don't show prompt if chat is completed
      if (chatState === CHAT_STATES.THANK_YOU) {
        console.log('[INACTIVITY] Not showing prompt - chat completed on', Platform.OS);
        return;
      }
      console.log('[INACTIVITY] Showing inactivity prompt on', Platform.OS);
      setShowInactivityPrompt(true);
    }, 20000); // 20 seconds for inactivity prompt
  };



  // Function to reset inactivity timer
  const resetInactivityTimer = () => {
    console.log('[INACTIVITY] Resetting inactivity timer');
    if (inactivityTimerRef.current) {
      clearTimeout(inactivityTimerRef.current);
    }
    if (inactivityPromptRef.current) {
      clearTimeout(inactivityPromptRef.current);
    }
    setShowInactivityPrompt(false);
    startInactivityTimer();
  };

  // Function to handle inactivity prompt tap
  const handleInactivityPromptTap = () => {
    setShowInactivityPrompt(false);
    resetInactivityTimer();
  };

  // Reset timer on user interactions (but not during restore)
  useEffect(() => {
    // Only reset timer if we have messages and chat is active, and not during initial load
    // But don't reset on every message/state change - only on actual user interactions
    if (messages.length > 0 && chatState !== CHAT_STATES.THANK_YOU && isChatFullyLoaded) {
      // Don't auto-reset timer on message changes - only on user interactions
      console.log('[INACTIVITY] Timer active but not resetting on message/state change');
    }
  }, [messages.length, chatState, isChatFullyLoaded]);

  // Reset timer when user types in elaboration
  useEffect(() => {
    if (elaboration.length > 0 && chatState === CHAT_STATES.ELABORATION) {
      resetInactivityTimer();
    }
  }, [elaboration, chatState]);

  // Reset timer when user types in edit text
  useEffect(() => {
    if (editText.length > 0 && showEditText) {
      resetInactivityTimer();
    }
  }, [editText, showEditText]);

  // Start inactivity timer after chat is fully loaded and stable
  useEffect(() => {
    // Only start timer if we have a logged in user and the chat is in a stable state
    if (loggedInEmployeeId && messages.length > 0 && chatState !== CHAT_STATES.THANK_YOU) {
      // Add a small delay to ensure everything is stable
      const timer = setTimeout(() => {
        console.log('[INACTIVITY] Starting timer after chat is stable on', Platform.OS);
        setIsChatFullyLoaded(true);
        startInactivityTimer();
      }, 1000); // 1 second delay to ensure reload is complete
      
      return () => clearTimeout(timer);
    }
  }, [loggedInEmployeeId, messages.length, chatState]);

  // Cleanup inactivity timers on unmount
  useEffect(() => {
    return () => {
      if (inactivityTimerRef.current) {
        clearTimeout(inactivityTimerRef.current);
      }
      if (inactivityPromptRef.current) {
        clearTimeout(inactivityPromptRef.current);
      }
    };
  }, []);

  // Debug video state
  useEffect(() => {
    console.log('[VIDEO DEBUG] showVideo state:', showVideo);
    console.log('[VIDEO DEBUG] chatState:', chatState);
    console.log('[VIDEO DEBUG] selectedMood:', selectedMood);
    console.log('[VIDEO DEBUG] Platform:', Platform.OS);
    console.log('[VIDEO DEBUG] Platform Version:', Platform.Version);
  }, [showVideo, chatState, selectedMood]);

  // Handle GIF loading timeout
  useEffect(() => {
    if (showVideo && gifLoading) {
      const timeout = setTimeout(() => {
        console.log('[GIF TIMEOUT] GIF loading timed out after 5 seconds');
        setGifLoadError(true);
        setGifLoading(false);
      }, 5000); // 5 second timeout

      return () => clearTimeout(timeout);
    }
  }, [showVideo, gifLoading]);

  // Check if GIF animation is supported
  useEffect(() => {
    // On some devices, GIF animation might be disabled
    if (Platform.OS === 'android') {
      // Try to detect if GIF animation is working
      const testGifAnimation = () => {
        console.log('[GIF ANIMATION] Testing GIF animation support');
        // This will help us know if GIFs are animating
        setTimeout(() => {
          if (gifLoading && !gifLoadError) {
            console.log('[GIF ANIMATION] GIF appears to be loading, animation should work');
          }
        }, 2000);
      };
      testGifAnimation();
    }
  }, []);

  // Function to refresh GIFs if they're not animating
  const refreshGifs = () => {
    console.log('[GIF REFRESH] Refreshing GIFs to ensure animation');
    setGifRefreshKey(prev => prev + 1);
  };

  // Auto-refresh GIFs after a delay to ensure animation
  useEffect(() => {
    if (showVideo && !gifLoadError && !gifLoading) {
      const autoRefreshTimer = setTimeout(() => {
        console.log('[GIF AUTO-REFRESH] Auto-refreshing GIFs to ensure animation');
        refreshGifs();
      }, 3000); // Refresh after 3 seconds

      return () => clearTimeout(autoRefreshTimer);
    }
  }, [showVideo, gifLoadError, gifLoading]);

  const handleBracketEdit = (oldText, newText) => {
    // Extract all brackets from the original text
    const bracketRegex = /\[([^\]]*)\]/g;
    const originalBrackets = [];
    let match;
    
    while ((match = bracketRegex.exec(oldText)) !== null) {
      originalBrackets.push({
        start: match.index,
        end: match.index + match[0].length,
        content: match[1],
        fullMatch: match[0]
      });
    }
    
    // If no brackets found, return the original text
    if (originalBrackets.length === 0) {
      return oldText;
    }
    
    // Extract all brackets from the new text
    const newBracketMatches = newText.match(/\[([^\]]*)\]/g);
    
    // If the number of brackets doesn't match, return original text
    if (!newBracketMatches || newBracketMatches.length !== originalBrackets.length) {
      return oldText;
    }
    
    // Build the new text by replacing only the content within brackets
    let result = oldText;
    let offset = 0;
    
    for (let i = 0; i < originalBrackets.length; i++) {
      const bracket = originalBrackets[i];
      const newContent = newBracketMatches[i].replace(/[\[\]]/g, '');
      
      // Calculate adjusted positions
      const adjustedStart = bracket.start + offset;
      const adjustedEnd = bracket.end + offset;
      
      // Replace only the content within this bracket
      const beforeBracket = result.substring(0, adjustedStart);
      const afterBracket = result.substring(adjustedEnd);
      result = beforeBracket + `[${newContent}]` + afterBracket;
      
      // Update offset for next bracket
      const oldLength = bracket.content.length;
      const newLength = newContent.length;
      offset += (newLength - oldLength);
    }
    
    return result;
  };

  // Store timeout IDs so they can be cleared if user selects an option early
  const optionTimeoutsRef = useRef([]);
  
  const displayOptionsSequentially = (options) => {
    // Clear any existing timeouts to prevent race conditions
    optionTimeoutsRef.current.forEach(timeoutId => clearTimeout(timeoutId));
    optionTimeoutsRef.current = []; // Reset the timeouts array
    
    setVisibleOptions([]);
    setShowOptionsSequentially(true);
    
    options.forEach((option, index) => {
      const timeoutId = setTimeout(() => {
        setVisibleOptions(prev => [...prev, option]);
        // Scroll to show options after each one appears
        const scrollTimeoutId = setTimeout(() => {
          if (scrollViewRef.current) {
            scrollViewRef.current.scrollToEnd({ animated: true });
          }
          optionTimeoutsRef.current.push(scrollTimeoutId);
        }, 100); // Small delay to ensure rendering
      }, (index + 1) * 800); // 800ms delay between each option
      
      optionTimeoutsRef.current.push(timeoutId);
    });
  };

  // Function to save incomplete chat
  const saveIncompleteChat = async () => {
    if (!loggedInEmployeeId) {
      console.log('[SAVE] Skipped: No loggedInEmployeeId');
      return;
    }
    
    // Save even if no messages yet, to track the initial state
    if (messages.length === 0 && chatState === CHAT_STATES.MOOD_SELECTION) {
      console.log('[SAVE] Saving initial chat state');
    }
    
    try {
      const incompleteChatData = {
        employeeId: loggedInEmployeeId,
        employeeName: userName,
        messages: messages,
        chatState: chatState,
        selectedMood: selectedMood,
        selectedOption: selectedOption,
        selectedSecondaryOption: selectedSecondaryOption,
        selectedThirdOption: selectedThirdOption,
        selectedFourthOption: selectedFourthOption,
        currentFlow: currentFlow,
        currentStep: currentStep,
        elaboration: elaboration,
        qaPairs: qaPairs,
        sadReasonKey: sadReasonKey,
        madReasonKey: madReasonKey,
        timestamp: serverTimestamp(),
        lastUpdated: new Date().toISOString()
      };
      console.log('[SAVE] Attempting to save incomplete chat:', incompleteChatData);
      
      // Check if incomplete chat already exists for this employeeId
      const incompleteQuery = query(
        collection(db, 'incompleteChats'),
        where('employeeId', '==', loggedInEmployeeId)
      );
      const incompleteSnapshot = await getDocs(incompleteQuery);
      
      if (!incompleteSnapshot.empty) {
        const docId = incompleteSnapshot.docs[0].id;
        await setDoc(doc(db, 'incompleteChats', docId), incompleteChatData);
        console.log('[SAVE] Incomplete chat updated for employeeId:', loggedInEmployeeId, 'DocId:', docId);
      } else {
        const docRef = await addDoc(collection(db, 'incompleteChats'), incompleteChatData);
        console.log('[SAVE] Incomplete chat saved for employeeId:', loggedInEmployeeId, 'DocId:', docRef.id);
      }
    } catch (error) {
      console.error('[SAVE] Error saving incomplete chat for employeeId:', loggedInEmployeeId, error);
    }
  };

  // Function to restore incomplete chat
  const restoreIncompleteChat = async (incompleteData) => {
    try {
      console.log('[RESTORE] Starting restore process for incomplete chat');
      console.log('[RESTORE] Incomplete data received:', incompleteData);
      
      // Check if chat was already completed
      if (incompleteData.chatState === CHAT_STATES.THANK_YOU) {
        console.log('[RESTORE] Chat was already completed, starting fresh');
        // Delete the completed chat document
        await deleteIncompleteChat();
        return false; // Don't restore, start fresh
      }
      
      console.log('[RESTORE] Chat not completed, proceeding with restoration');
      
      // Convert time strings back to Date objects for messages
      const restoredMessages = (incompleteData.messages || []).map(msg => ({
        ...msg,
        time: msg.time ? new Date(msg.time) : new Date()
      }));
      console.log('[RESTORE] Restored messages:', restoredMessages);
      
      setMessages(restoredMessages);
      setChatState(incompleteData.chatState || CHAT_STATES.MOOD_SELECTION);
      setSelectedMood(incompleteData.selectedMood || null);
      setSelectedOption(incompleteData.selectedOption || null);
      setSelectedSecondaryOption(incompleteData.selectedSecondaryOption || null);
      setSelectedThirdOption(incompleteData.selectedThirdOption || null);
      setSelectedFourthOption(incompleteData.selectedFourthOption || null);
      setCurrentFlow(incompleteData.currentFlow || null);
      setCurrentStep(incompleteData.currentStep || null);
      setElaboration(incompleteData.elaboration || '');
      setQaPairs(incompleteData.qaPairs || []);
      setSadReasonKey(incompleteData.sadReasonKey || null);
      setMadReasonKey(incompleteData.madReasonKey || null);
      
      console.log('[RESTORE] State variables set successfully');
      
      // Handle video visibility based on mood selection
      if (incompleteData.selectedMood) {
        setShowVideo(false); // Hide video if mood was already selected
      } else {
        setShowVideo(true); // Show video if no mood was selected yet
      }
      
      console.log('[RESTORE] Restored incomplete chat data:', incompleteData);
      console.log('[RESTORE] State after restore:', {
        messages: restoredMessages,
        chatState: incompleteData.chatState,
        selectedMood: incompleteData.selectedMood,
        selectedOption: incompleteData.selectedOption,
        selectedSecondaryOption: incompleteData.selectedSecondaryOption,
        selectedThirdOption: incompleteData.selectedThirdOption,
        selectedFourthOption: incompleteData.selectedFourthOption,
        currentFlow: incompleteData.currentFlow,
        currentStep: incompleteData.currentStep,
        elaboration: incompleteData.elaboration,
        qaPairs: incompleteData.qaPairs
      });
      // Continue the conversation based on current state
      setTimeout(() => {
        console.log('[RESTORE] Continuing conversation based on restored state');
        if (incompleteData.chatState === CHAT_STATES.MOOD_SELECTION && !incompleteData.selectedMood) {
          showMoodSelection();
        } else if (incompleteData.currentStep && incompleteData.currentFlow) {
          const step = incompleteData.currentFlow[incompleteData.currentStep];
          if (step && step.options) {
            const optionsArray = Object.entries(step.options).map(([optionText, nextStepKey]) => ({
              text: optionText,
              nextStepKey: nextStepKey
            }));
            displayOptionsSequentially(optionsArray);
          } else if (step && step.question_edit) {
            setEditText(step.question_edit);
            setEditTextPlaceholder(step.question_edit);
            setShowEditText(true);
            setPendingNextStep(step.next);
          }
        } else if (incompleteData.chatState === CHAT_STATES.ELABORATION) {
          // The input field will be rendered automatically
        }
        setTimeout(() => {
          if (scrollViewRef.current) {
            scrollViewRef.current.scrollToEnd({ animated: true });
          }
        }, 200);
        // Save the restored conversation back to incompleteChats after a short delay
        saveIncompleteChat();
      }, 500);
      console.log('[RESTORE] Incomplete chat restored and continuing');
      
      // Start inactivity timer after restoration
      setTimeout(() => {
        console.log('[RESTORE] Starting inactivity timer after restoration');
        setIsChatFullyLoaded(true);
        startInactivityTimer();
      }, 1000);
      
      return true;
    } catch (error) {
      console.error('[RESTORE] Error restoring incomplete chat:', error);
      return false;
    }
  };

  // Function to delete incomplete chat
  const deleteIncompleteChat = async () => {
    if (!loggedInEmployeeId) return;
    
    try {
      const incompleteQuery = query(
        collection(db, 'incompleteChats'),
        where('employeeId', '==', loggedInEmployeeId)
      );
      const incompleteSnapshot = await getDocs(incompleteQuery);
      
      if (!incompleteSnapshot.empty) {
        const docId = incompleteSnapshot.docs[0].id;
        await deleteDoc(doc(db, 'incompleteChats', docId));
        console.log('Incomplete chat deleted for employeeId:', loggedInEmployeeId);
      } else {
        console.log('No incomplete chat found to delete for employeeId:', loggedInEmployeeId);
      }
    } catch (error) {
      console.error('Error deleting incomplete chat for employeeId:', loggedInEmployeeId, error);
    }
  };

  // Load custom fonts
  useEffect(() => {
    const loadFonts = async () => {
      try {
        await Font.loadAsync({
          'SpaceMono-Regular': require('../assets/fonts/SpaceMono-Regular.ttf'),
        });
        setFontsLoaded(true);
        console.log('Fonts loaded successfully');
      } catch (error) {
        console.error('Error loading fonts:', error);
        setFontsLoaded(true); // Continue without custom fonts
      }
    };
    
    loadFonts();
  }, []);

  useEffect(() => {
    const initializeChat = async () => {
      console.log('[RELOAD] Starting chat initialization for employeeId:', loggedInEmployeeId);
      if (!loggedInEmployeeId) return;
      
      // First, fetch the user's name
      let nameToShow = 'User';
      try {
        const userDoc = await getDoc(doc(db, 'employees', loggedInEmployeeId));
        if (userDoc.exists()) {
          nameToShow = userDoc.data().name || 'User';
        }
      } catch (error) {
        // fallback to 'User'
      }
      setUserName(nameToShow);
      console.log('[RELOAD] User name set to:', nameToShow);

      // Check for incomplete chat first using employeeId
      const incompleteQuery = query(
        collection(db, 'incompleteChats'),
        where('employeeId', '==', loggedInEmployeeId)
      );
      const incompleteSnapshot = await getDocs(incompleteQuery);
      
      if (!incompleteSnapshot.empty) {
        // Restore incomplete chat
        const firstDoc = incompleteSnapshot.docs[0];
        const incompleteData = firstDoc.data();
        console.log('[RELOAD] Found incomplete chat data:', incompleteData);
        console.log('[RELOAD] Chat state in incomplete data:', incompleteData.chatState);
        console.log('[RELOAD] Expected THANK_YOU state:', CHAT_STATES.THANK_YOU);
        
        // If the doc is empty or invalid, treat as no incomplete chat
        if (!incompleteData || Object.keys(incompleteData).length === 0 || incompleteData.chatState === CHAT_STATES.THANK_YOU) {
          console.log('[RELOAD] Incomplete chat doc is empty/invalid or completed. Deleting and starting fresh.');
          console.log('[RELOAD] Empty data check:', !incompleteData);
          console.log('[RELOAD] Empty object check:', Object.keys(incompleteData).length === 0);
          console.log('[RELOAD] Completed check:', incompleteData.chatState === CHAT_STATES.THANK_YOU);
          try {
            await deleteDoc(doc(db, 'incompleteChats', firstDoc.id));
          } catch (e) {
            console.log('[RELOAD] Failed to delete invalid incomplete chat doc:', e);
          }
          
          // Reset all state variables for fresh start after deleting completed chat
          setMessages([]);
          setChatState(CHAT_STATES.MOOD_SELECTION);
          setSelectedMood(null);
          setSelectedOption(null);
          setSelectedSecondaryOption(null);
          setSelectedThirdOption(null);
          setSelectedFourthOption(null);
          setCurrentFlow(null);
          setCurrentStep(null);
          setElaboration('');
          setQaPairs([]);
          setSadReasonKey(null);
          setMadReasonKey(null);
          setShowOptions(false);
          setShowSecondaryOptions(false);
          setShowThirdOptions(false);
          setShowFourthOptions(false);
          setShowEditText(false);
          setEditText('');
          setShowOptionsSequentially(false);
          setVisibleOptions([]);
          setShowThinkingDots(false);
          setShowVideo(true);
          setGifLoadError(false);
          setGifLoading(true);
          
          // Start fresh with welcome messages
          const welcomeMessage1 = {
            id: 1,
            text: `Hi, ${nameToShow}!`,
            isUser: false,
            time: new Date()
          };
          const welcomeGifMessage = {
            id: 2,
            text: "Welcome to mDojo! 👋",
            isUser: false,
            time: new Date(),
            isWelcomeGif: true,
            gifSource: require('../assets/images/welcome.gif')
          };
          const welcomeMessage2 = {
            id: 3,
            text: "Welcome to mDojo!",
            isUser: false,
            time: new Date(),
            isWelcomeText: true
          };
          setMessages([welcomeMessage1, welcomeGifMessage, welcomeMessage2]);
          setTimeout(() => {
            showMoodSelection();
            // Save initial state after welcome messages
            setTimeout(() => {
              saveIncompleteChat();
            }, 1000);
          }, 800);
          setChatState(CHAT_STATES.MOOD_SELECTION);
          console.log('[RELOAD] Started fresh chat with welcome messages after deleting completed chat');
          
          // Start inactivity timer immediately after chat is set up
          setTimeout(() => {
            console.log('[RELOAD] Starting inactivity timer for fresh chat');
            setIsChatFullyLoaded(true);
            startInactivityTimer();
          }, 2000);
          
          return; // Don't proceed with normal initialization
        } else {
          console.log('[RELOAD] Found incomplete chat for employeeId:', loggedInEmployeeId);
          console.log('[RELOAD] Attempting to restore incomplete chat...');
          const restored = await restoreIncompleteChat(incompleteData);
          
          if (restored) {
            console.log('[RELOAD] Incomplete chat restored successfully for employeeId:', loggedInEmployeeId);
            return; // Don't proceed with normal initialization
          } else {
            console.log('[RELOAD] Failed to restore incomplete chat, will start fresh');
          }
        }
      } else {
        console.log('[RELOAD] No incomplete chat found for employeeId:', loggedInEmployeeId);
        
        // Reset all state variables for fresh start
        setMessages([]);
        setChatState(CHAT_STATES.MOOD_SELECTION);
        setSelectedMood(null);
        setSelectedOption(null);
        setSelectedSecondaryOption(null);
        setSelectedThirdOption(null);
        setSelectedFourthOption(null);
        setCurrentFlow(null);
        setCurrentStep(null);
        setElaboration('');
        setQaPairs([]);
        setSadReasonKey(null);
        setMadReasonKey(null);
        setShowOptions(false);
        setShowSecondaryOptions(false);
        setShowThirdOptions(false);
        setShowFourthOptions(false);
        setShowEditText(false);
        setEditText('');
        setShowOptionsSequentially(false);
        setVisibleOptions([]);
        setShowThinkingDots(false);
        setShowVideo(true);
        setGifLoadError(false);
        setGifLoading(true);
        
        // If no incomplete chat, start fresh with welcome messages
        const welcomeMessage1 = {
          id: 1,
          text: `Hi, ${nameToShow}!`,
          isUser: false,
          time: new Date()
        };
        const welcomeGifMessage = {
          id: 2,
          text: "Welcome to mDojo! 👋",
          isUser: false,
          time: new Date(),
          isWelcomeGif: true,
          gifSource: require('../assets/images/welcome.gif')
        };
        const welcomeMessage2 = {
          id: 3,
          text: "Welcome to mDojo!",
          isUser: false,
          time: new Date(),
          isWelcomeText: true
        };
        setMessages([welcomeMessage1, welcomeGifMessage, welcomeMessage2]);
        setTimeout(() => {
          showMoodSelection();
          // Save initial state after welcome messages
          setTimeout(() => {
            saveIncompleteChat();
          }, 1000);
        }, 800);
        setChatState(CHAT_STATES.MOOD_SELECTION);
        console.log('[RELOAD] Started fresh chat with welcome messages');
        
        // Start inactivity timer immediately after chat is set up
        setTimeout(() => {
          console.log('[RELOAD] Starting inactivity timer for fresh chat');
          setIsChatFullyLoaded(true);
          startInactivityTimer();
        }, 2000);
      }
    };

    initializeChat();
  }, [loggedInEmployeeId]);

  // Save incomplete chat when component unmounts or when important state changes
  useEffect(() => {
    const handleBeforeUnload = () => {
      if (loggedInEmployeeId && messages.length > 0 && chatState !== CHAT_STATES.THANK_YOU) {
        saveIncompleteChat();
      }
    };

    // For web
    if (Platform.OS === 'web') {
      window.addEventListener('beforeunload', handleBeforeUnload);
      return () => window.removeEventListener('beforeunload', handleBeforeUnload);
    }
  }, [loggedInEmployeeId, messages, chatState]);

  // Auto-save incomplete chat whenever important state changes
  useEffect(() => {
    if (!loggedInEmployeeId || chatState === CHAT_STATES.THANK_YOU) return;

    // Save immediately when state changes
    console.log('[AUTO-SAVE] Triggered by state change:', { chatState, messagesLength: messages.length });
    saveIncompleteChat();
  }, [loggedInEmployeeId, messages, chatState, selectedMood, selectedOption, selectedSecondaryOption, selectedThirdOption, selectedFourthOption, currentFlow, currentStep, elaboration, qaPairs]);

  // Additional save trigger for user interactions after restoration
  useEffect(() => {
    if (!loggedInEmployeeId || chatState === CHAT_STATES.THANK_YOU) return;

    // Save when user interacts with the chat (any message addition)
    const lastMessage = messages[messages.length - 1];
    if (lastMessage && lastMessage.time) {
      console.log('[AUTO-SAVE] Triggered by message addition');
      saveIncompleteChat();
    }
  }, [messages.length]); // Trigger on message count change

  // Handle app state changes for mobile platforms
  useEffect(() => {
    const handleAppStateChange = (nextAppState) => {
      if (nextAppState === 'background' || nextAppState === 'inactive') {
        if (loggedInEmployeeId && messages.length > 0 && chatState !== CHAT_STATES.THANK_YOU) {
          saveIncompleteChat();
        }
      }
    };

    if (Platform.OS !== 'web') {
      const subscription = AppState.addEventListener('change', handleAppStateChange);
      return () => subscription?.remove();
    }
  }, [loggedInEmployeeId, messages, chatState]);

  // Cleanup function when component unmounts
  useEffect(() => {
    return () => {
      if (loggedInEmployeeId && messages.length > 0 && chatState !== CHAT_STATES.THANK_YOU) {
        saveIncompleteChat();
      }
    };
  }, [loggedInEmployeeId, messages, chatState]);

  useEffect(() => {
    if (scrollViewRef.current) {
      // Add a small delay to ensure content is rendered before scrolling
      setTimeout(() => {
        scrollViewRef.current.scrollToEnd({ animated: true });
      }, 100);
    }
  }, [messages, showOptions, showSecondaryOptions, showThirdOptions, showFourthOptions, showOptionsSequentially, visibleOptions, showEditText]);

  useEffect(() => {
    Animated.timing(fadeAnim, {
      toValue: 1,
      duration: 300,
      useNativeDriver: true,
    }).start();
  }, []);

  const saveEmployeeMood = async (id, mood) => {
    try {
      if (!mood) {
        console.warn("Missing employeeId or mood", { id, mood });
        return false;
      }
      
      console.log("Saving employee mood:", { employeeId: id, mood });
      
      // Save to chatResponses collection for dashboard
      await addDoc(collection(db, 'chatResponses'), {
        employeeId: id.trim(),
        mood: mood,
        timestamp: serverTimestamp(),
        date: new Date().toISOString().split('T')[0],
        // Include additional context if available
        ...(selectedOption && { primaryOption: selectedOption }),
        ...(selectedSecondaryOption && { secondaryOption: selectedSecondaryOption }),
        ...(selectedThirdOption && { thirdOption: selectedThirdOption }),
        ...(selectedFourthOption && { fourthOption: selectedFourthOption }),
        ...(elaboration && { elaboration: elaboration })
      });
      
      // Also save to employeeMoods for backward compatibility
      await addDoc(collection(db, 'employeeMoods'), {
        employeeId: id.trim(),
        mood: mood,
        timestamp: serverTimestamp()
      });
      
      console.log("Employee mood saved successfully");
      return true;
    } catch (error) {
      console.error("Error saving employee mood: ", error);
      Alert.alert("Error", "Failed to save mood. Please try again.");
      return false;
    }
  };

  const updateMoodCount = async (mood) => {
    try {
      if (!mood) {
        console.warn("No mood provided for count update");
        return;
      }
      
      // Update daily mood count
      const dailyMoodRef = doc(db, 'moodCounts', 'daily');
      await setDoc(dailyMoodRef, {
        [mood]: increment(1),
        lastUpdated: serverTimestamp(),
        // Keep track of the last update time
        lastUpdatedFormatted: new Date().toISOString()
      }, { merge: true });
      
      // Also update the current counts for backward compatibility
      const moodCountRef = doc(db, 'moodCounts', 'currentCounts');
      await setDoc(moodCountRef, {
        [mood]: increment(1),
        lastUpdated: serverTimestamp()
      }, { merge: true });
      
      console.log("Mood count updated successfully for:", mood);
    } catch (error) {
      console.error("Error updating mood count: ", error);
      Alert.alert("Error", "Failed to update mood count.");
    }
  };
  
  // Function to save complete chat response (including all options and elaboration)
  const saveChatResponse = async () => {
    try {
      const responseData = {
        employeeId: loggedInEmployeeId,
        mood: selectedMood,
        timestamp: serverTimestamp(),
        date: new Date().toISOString().split('T')[0],
        ...(selectedOption && { primaryOption: selectedOption }),
        ...(selectedSecondaryOption && { secondaryOption: selectedSecondaryOption }),
        ...(selectedThirdOption && { thirdOption: selectedThirdOption }),
        ...(selectedFourthOption && { fourthOption: selectedFourthOption }),
        ...(elaboration && { elaboration: elaboration })
      };
      
      setConversationResponses(prev => [...prev, responseData]);
      console.log('Chat response saved successfully');
    } catch (error) {
      console.error("Error saving chat response: ", error);
      Alert.alert("Error", "Failed to save chat response. Please try again.");
    }
  };

// Add goToStep function
const goToStep = (stepKey) => {
  setCurrentStep(stepKey);
  const step = currentFlow[stepKey];
  if (step && step.question) {
    // Show question immediately
    const botMsg = {
      id: Date.now(),
      text: step.question,
      isUser: false,
      time: new Date()
    };
    setMessages(prev => [...prev, botMsg]);
    // saveChatMessage(loggedInEmployeeId, botMsg); // REMOVED
    
    // Add delay for options if they exist
    if (step.options) {
      setShowThinkingDots(true);
      // Scroll to show thinking dots
      setTimeout(() => {
        if (scrollViewRef.current) {
          scrollViewRef.current.scrollToEnd({ animated: true });
        }
      }, 100);
      
      setTimeout(() => {
        setShowThinkingDots(false);
        // Show options sequentially
        const optionsArray = Object.entries(step.options).map(([optionText, nextStepKey]) => ({
          text: optionText,
          nextStepKey: nextStepKey
        }));
        displayOptionsSequentially(optionsArray);
      }, 800); // 0.8 second delay for options
    }
  }
};

  const handleMoodSelect = (mood) => {
    resetInactivityTimer(); // Reset timer on mood selection
    setSelectedMood(mood);
    setShowVideo(false); // Hide video after mood selection
    setGifLoadError(false); // Reset GIF error state
    setGifLoading(false); // Reset loading state
    let flow = null;
    if (mood === 'glad') flow = mdojoFullFlow.Glad;
    else if (mood === 'sad') flow = mdojoFullFlow.Sad;
    else if (mood === 'mad') flow = mdojoFullFlow.Mad;

    setCurrentFlow(flow);
    setMessages(prev => [
      ...prev,
      { id: Date.now(), text: mood.charAt(0).toUpperCase() + mood.slice(1), isUser: true, time: new Date() }
    ]);
    
    // Save immediately after mood selection
    setTimeout(() => {
      saveIncompleteChat();
    }, 100);
    
    // Show question immediately, then delay for options
    goToStepWithFlow('step1', flow);
  };

// New helper function:
const goToStepWithFlow = (stepKey, flowOverride) => {
  const flow = flowOverride || currentFlow;
  setCurrentStep(stepKey);
  const step = flow[stepKey];
  if (step && step.question) {
    // Show question immediately
    setMessages(prev => [
      ...prev,
      {
        id: Date.now(),
        text: step.question,
        isUser: false,
        time: new Date()
      }
    ]);
    
    // Add delay for options if they exist
    if (step.options) {
      setShowThinkingDots(true);
      // Scroll to show thinking dots
      setTimeout(() => {
        if (scrollViewRef.current) {
          scrollViewRef.current.scrollToEnd({ animated: true });
        }
      }, 100);
      
      setTimeout(() => {
        setShowThinkingDots(false);
        // Show options sequentially
        const optionsArray = Object.entries(step.options).map(([optionText, nextStepKey]) => ({
          text: optionText,
          nextStepKey: nextStepKey
        }));
        displayOptionsSequentially(optionsArray);
      }, 800); // 0.8 second delay for options
    }
  }
};

  const handleElaborationSubmit = async () => {
    if (!elaboration.trim()) return;

    resetInactivityTimer(); // Reset timer on elaboration submit
    const elaborationMessage = {
      id: Date.now(),
      text: elaboration,
      isUser: true,
      time: new Date()
    };

    setMessages(prev => [...prev, elaborationMessage]);
    setElaboration('');
    
    await saveChatResponse();
    
    // Add thinking delay before showing final messages
    setShowThinkingDots(true);
    setTimeout(() => {
      setShowThinkingDots(false);
      showFinalMessages();
    }, 800); // 0.8 second thinking delay
  };

  const handleSend = () => {
    if (chatState === CHAT_STATES.ELABORATION) {
      handleElaborationSubmit();
    }
  };

  const isSendDisabled = () => {
     if (chatState === CHAT_STATES.ELABORATION) {
    return !elaboration || elaboration.trim().length < 5;
  }
    if (chatState === CHAT_STATES.MOOD_SELECTION || 
        chatState === CHAT_STATES.THANK_YOU ||
        chatState === CHAT_STATES.FOLLOW_UP ||
        chatState === CHAT_STATES.SECONDARY_QUESTION) {
      return true;
    }
    
    return !message || !message.trim();
  };

  const showMoodSelection = () => {
    setChatState(CHAT_STATES.MOOD_SELECTION);
    
    // Scroll to show mood selection after a short delay
    setTimeout(() => {
      if (scrollViewRef.current) {
        scrollViewRef.current.scrollToEnd({ animated: true });
      }
    }, 200);
  };

  const showInitialQuestion = (mood) => {
    const flow = mood === 'glad' ? GLAD_FLOW : mood === 'sad' ? SAD_FLOW : MAD_FLOW;
    
    const firstMessage = {
      id: Date.now() + 1,
      text: flow.initialQuestion.messages[0],
      isUser: false,
      time: new Date()
    };
    
    setMessages(prev => [...prev, firstMessage]);
    
    setTimeout(() => {
      const gifMessage = {
        id: Date.now() + 2,
        text: flow.initialQuestion.messages[1],
        isUser: false,
        time: new Date(),
        isGif: true
      };
      setMessages(prev => [...prev, gifMessage]);
      
      setTimeout(() => {
        const questionMessage = {
          id: Date.now() + 3,
          text: flow.initialQuestion.messages[2],
          isUser: false,
          time: new Date(),
          isFollowUp: true
        };
        setMessages(prev => [...prev, questionMessage]);
        setChatState(CHAT_STATES.FOLLOW_UP);
        setShowOptions(true);
      }, 1000);
    }, 1000);
  };

  const handleOptionSelect = (optionText, nextStepKey) => {
  resetInactivityTimer(); // Reset timer on option selection
  console.log('[DEBUG] handleOptionSelect called with:', { optionText, nextStepKey, currentStep, currentFlow });
  
  // Clear any pending option display timeouts to prevent options from appearing after selection
  optionTimeoutsRef.current.forEach(timeoutId => clearTimeout(timeoutId));
  optionTimeoutsRef.current = [];
  
  // If we're in sequential display mode, immediately show all options
  if (showOptionsSequentially && currentStep && currentFlow) {
    const step = currentFlow[currentStep];
    if (step && step.options) {
      // Show all options immediately
      const allOptionsArray = Object.entries(step.options).map(([text, nextStep]) => ({
        text: text,
        nextStepKey: nextStep
      }));
      setVisibleOptions(allOptionsArray);
    }
  }
  
  // Track Sad step1 selection and map to correct dynamic step names
  if (currentFlow && currentFlow === mdojoFullFlow.Sad && currentStep === 'step1') {
    console.log('[DEBUG] Sad flow step1 option selected:', JSON.stringify(optionText));
    
    // Map step1 selections to the correct dynamic step names
    const step1ToDynamicStepMap = {
      '‍💼 Manager-related challenges': 'step3_manager_related_challenges',
      '👥 Difficult interactions with colleagues': 'step3_difficult_interactions_with_colleagues',
      '� Company culture or policies': 'step3_company_culture_or_policies',
      '❓ Lack of role clarity or direction': 'step3_lack_of_role_clariy_or_direction',
      '� Workspace, tools, or infrastructure issues': 'step3_workspace_tools_or_infrastructure_issues',
      '⚖️ Struggling with work-life balance': 'step3_struggling_with_work_life_balance',
      '😔 Feeling emotionally exhausted or overwhelmed': 'step3_feeling_emotionally_exhausted_or_overwhelmed'
    };
    
    // Try with the emoji
    let dynamicStepKey = step1ToDynamicStepMap[optionText];
    console.log('[DEBUG] Direct mapping result:', dynamicStepKey);
    
    // If no match found, try text-based matching
    if (!dynamicStepKey) {
      dynamicStepKey = matchStepFromText(optionText, 'Sad');
      console.log('[DEBUG] Text-based matching result:', dynamicStepKey);
    }
    
    // If not found, do a text-based match
    if (!dynamicStepKey) {
      console.log('[DEBUG] Trying text-based matching for:', optionText);
      
      // Common phrases to identify step mappings
      const textMatches = {
        "Manager-related": "step3_manager_related_challenges",
        "Difficult interactions": "step3_difficult_interactions_with_colleagues",
        "Company culture": "step3_company_culture_or_policies",
        "Lack of role": "step3_lack_of_role_clariy_or_direction",
        "Workspace, tools": "step3_workspace_tools_or_infrastructure_issues",
        "infrastructure issues": "step3_workspace_tools_or_infrastructure_issues",
        "Struggling with work-life": "step3_struggling_with_work_life_balance",
        "emotionally exhausted": "step3_feeling_emotionally_exhausted_or_overwhelmed",
        "overwhelmed": "step3_feeling_emotionally_exhausted_or_overwhelmed"
      };
      
      // Find matching text
      for (const [text, step] of Object.entries(textMatches)) {
        if (optionText.includes(text)) {
          dynamicStepKey = step;
          console.log('[DEBUG] Found text match:', text);
          break;
        }
      }
    }
    
    if (dynamicStepKey) {
      console.log('[DEBUG] Setting sadReasonKey for dynamic branching:', dynamicStepKey);
      setSadReasonKey(dynamicStepKey);
    }
  }
  // Dynamic Sad step3 branching after step2
  if (currentFlow && currentFlow === mdojoFullFlow.Sad && currentStep === 'step2' && nextStepKey === 'step3_dynamic') {
    console.log('[DEBUG] Sad flow detected with step2 -> step3_dynamic');
    
    // Map from step1 option text to specific dynamic step
    const step1ToDynamicStepMap = {
      '‍💼 Manager-related challenges': 'step3_manager_related_challenges',
      '👥 Difficult interactions with colleagues': 'step3_difficult_interactions_with_colleagues',
      '🏭 Company culture or policies': 'step3_company_culture_or_policies',
      '❓ Lack of role clarity or direction': 'step3_lack_of_role_clariy_or_direction',
      '🔧 Workspace, tools, or infrastructure issues': 'step3_workspace_tools_or_infrastructure_issues',
      '⚖️ Struggling with work-life balance': 'step3_struggling_with_work_life_balance',
      '😔 Feeling emotionally exhausted or overwhelmed': 'step3_feeling_emotionally_exhausted_or_overwhelmed'
    };

    console.log('[DEBUG] Option text:', optionText);
    
    // Try both with and without the emoji
    let dynamicStepKey = sadReasonKey;
    
    // If no sadReasonKey was set, try to determine from the dynamic step map
    if (!dynamicStepKey) {
      console.log('[DEBUG] No sadReasonKey found, trying text-based matching');
      
      // Common phrases to identify step mappings
      const textMatches = {
        "Manager-related": "step3_manager_related_challenges",
        "Difficult interactions": "step3_difficult_interactions_with_colleagues",
        "Company culture": "step3_company_culture_or_policies",
        "Lack of role": "step3_lack_of_role_clariy_or_direction",
        "Workspace, tools": "step3_workspace_tools_or_infrastructure_issues",
        "infrastructure issues": "step3_workspace_tools_or_infrastructure_issues",
        "Struggling with work-life": "step3_struggling_with_work_life_balance",
        "emotionally exhausted": "step3_feeling_emotionally_exhausted_or_overwhelmed",
        "overwhelmed": "step3_feeling_emotionally_exhausted_or_overwhelmed"
      };
      
      // Find matching text in QA pairs
      for (const pair of qaPairs) {
        if (pair.question === currentFlow.step1?.question) {
          for (const [text, step] of Object.entries(textMatches)) {
            if (pair.answer.includes(text)) {
              dynamicStepKey = step;
              console.log('[DEBUG] Found text match in QA pair:', text);
              break;
            }
          }
        }
      }
      
      // If still no match, use a default step
      if (!dynamicStepKey) {
        dynamicStepKey = "step3_manager_related_challenges";
        console.log('[DEBUG] Using default dynamic step key');
      }
    }
    
    console.log('[DEBUG] Dynamic step key:', dynamicStepKey);
    
    // Add user message
    const userMsg = {
      id: Date.now(),
      text: optionText,
      isUser: true,
      time: new Date()
    };
    setMessages(prev => [...prev, userMsg]);
    setQaPairs(prev => [
      ...prev,
      { question: currentFlow[currentStep]?.question, answer: optionText }
    ]);
    saveIncompleteChat();
    
    // Go to the dynamic step or fallback to step5 if not available
    if (currentFlow[dynamicStepKey]) {
      goToStep(dynamicStepKey);
    } else {
      console.log('[DEBUG] Dynamic step not found, falling back to step5');
      goToStep('step5');
    }
    return;
  }
  }
  // Track Mad step1 selection and map to correct dynamic step names
  if (currentFlow && currentFlow === mdojoFullFlow.Mad && currentStep === 'step1') {
    // Map step1 selections to the correct dynamic step names for Mad flow
    const step1ToDynamicStepMap = {
      '� Frustration with manager or leadership decisions': 'step3_frustration_with_manager_or_leadership_decisions',
      '⚔️ Tension or conflict with colleagues': 'step3_tension_or_conflict_with_colleagues',
      '⚖️ Unfair workload or lack of recognition': 'step3_unfair_workload_or_lack_of_recognition',
      '⏰ Missed deadlines or miscommunication': 'step3_missed_deadlines_or_miscommunication',
      '� Frustration with company policies or red tape': 'step3_frustration_with_company_policies_or_red_tape',
      '🚫 Feeling stuck or blocked in your work': 'step3_feeling_stuck_or_blocked_in_your_work',
      '� Too much change or unclear direction': 'step3_too_much_change_or_unclear_direction',
      '🔧 Infrastructure or facility-related issues': 'step3_infrastructure_or_facility_related_issues'
    };
    
    // No special early return handler - let the normal flow work
    
    // Log the exact optionText to help debug
    console.log('[DEBUG] Mad flow step1 option selected:', JSON.stringify(optionText));
    console.log('[DEBUG] Available mappings:', Object.keys(step1ToDynamicStepMap));
    
    // Try with the emoji
    let dynamicStepKey = step1ToDynamicStepMap[optionText];
    
    // If not found, use our helper to try text matching
    if (!dynamicStepKey) {
      console.log('[DEBUG] Direct match failed, trying helper function');
      dynamicStepKey = matchStepFromText(optionText, 'Mad');
      console.log('[DEBUG] Helper matching result:', dynamicStepKey);
    }
    }
    
    if (dynamicStepKey) {
      console.log('[DEBUG] Setting madReasonKey for dynamic branching:', dynamicStepKey);
      setMadReasonKey(dynamicStepKey);
    }
  }
  // Dynamic Mad step3 branching after step2
  if (currentFlow && currentFlow === mdojoFullFlow.Mad && currentStep === 'step2' && nextStepKey === 'step3_dynamic') {
    console.log('[DEBUG] Mad flow detected with step2 -> step3_dynamic');
    
    // Map from step1 option text to specific dynamic step
    const step1ToDynamicStepMap = {
      "😡 Frustration with manager or leadership decisions": "step3_frustration_with_manager_or_leadership_decisions",
      "😤 Tension or conflict with colleagues": "step3_tension_or_conflict_with_colleagues",
      "😒 Unfair workload or lack of recognition": "step3_unfair_workload_or_lack_of_recognition", 
      "😣 Missed deadlines or miscommunication": "step3_missed_deadlines_or_miscommunication",
      "🙄 Frustration with company policies or red tape": "step3_frustration_with_company_policies_or_red_tape",
      "😩 Feeling stuck or blocked in your work": "step3_feeling_stuck_or_blocked_in_your_work",
      "😫 Too much change or unclear direction": "step3_too_much_change_or_unclear_direction",
      "🤨 Infrastructure or facility related issues": "step3_infrastructure_or_facility_related_issues"
    };

    console.log('[DEBUG] Option text:', optionText);
    
    // Try both with and without the emoji
    let dynamicStepKey = madReasonKey;
    
    // If no madReasonKey was set, try to determine from the dynamic step map
    if (!dynamicStepKey) {
      console.log('[DEBUG] No madReasonKey found, trying text-based matching for:', optionText);
      
      // Common phrases to identify step mappings
      const textMatches = {
        "Frustration with manager": "step3_frustration_with_manager_or_leadership_decisions",
        "Tension or conflict": "step3_tension_or_conflict_with_colleagues",
        "Unfair workload": "step3_unfair_workload_or_lack_of_recognition",
        "Missed deadlines": "step3_missed_deadlines_or_miscommunication",
        "company policies": "step3_frustration_with_company_policies_or_red_tape",
        "Feeling stuck": "step3_feeling_stuck_or_blocked_in_your_work",
        "Too much change": "step3_too_much_change_or_unclear_direction",
        "Infrastructure": "step3_infrastructure_or_facility_related_issues"
      };
      
      // Find matching text
      for (const [text, step] of Object.entries(textMatches)) {
        if (optionText.includes(text)) {
          dynamicStepKey = step;
          console.log('[DEBUG] Found text match:', text);
          break;
        }
      }
      
      // If still no match, use a default step
      if (!dynamicStepKey) {
        dynamicStepKey = "step3_frustration_with_manager_or_leadership_decisions";
        console.log('[DEBUG] Using default dynamic step key');
      }
    }
    
    console.log('[DEBUG] Dynamic step key:', dynamicStepKey);
    
    // Add user message
    const userMsg = {
      id: Date.now(),
      text: optionText,
      isUser: true,
      time: new Date()
    };
    setMessages(prev => [...prev, userMsg]);
    setQaPairs(prev => [
      ...prev,
      { question: currentFlow[currentStep]?.question, answer: optionText }
    ]);
    saveIncompleteChat();
    
    // Go to the dynamic step or fallback to step5 if not available
    if (currentFlow[dynamicStepKey]) {
      goToStep(dynamicStepKey);
    } else {
      console.log('[DEBUG] Dynamic step not found, falling back to step5');
      goToStep('step5');
    }
    return;
  } // End of dynamic step handling
  
  // Default behavior
  const userMsg = {
    id: Date.now(),
    text: optionText,
    isUser: true,
    time: new Date()
  };
  setMessages(prev => {
    console.log('[DEBUG] Adding message:', userMsg);
    return [...prev, userMsg];
  });
  // saveChatMessage(loggedInEmployeeId, userMsg); // REMOVED
  setQaPairs(prev => [
    ...prev,
    { question: currentFlow[currentStep]?.question, answer: optionText }
  ]);
  
  // Save immediately after option selection
  saveIncompleteChat();
  
  // Completely reset sequential options state
  setShowOptionsSequentially(false);
  setVisibleOptions([]);
  
  // Clear any remaining timeouts again to be absolutely sure
  optionTimeoutsRef.current.forEach(timeoutId => clearTimeout(timeoutId));
  optionTimeoutsRef.current = [];
  
  // Process next step immediately (question will show immediately, options will delay)
  const step = currentFlow[nextStepKey];
  if (step && step.end === true) {
    showFinalMessages();
    return;
  }
  if (step && step.question_edit) {
    setEditText(step.question_edit);
    setEditTextPlaceholder(step.question_edit);
    setShowEditText(true);
    setPendingNextStep(step.next);
    setCurrentStep(nextStepKey);
    
    // Scroll to show edit text input after a short delay
    setTimeout(() => {
      if (scrollViewRef.current) {
        scrollViewRef.current.scrollToEnd({ animated: true });
      }
    }, 200);
  } else if (step && step.messages) {
    setPendingMessages(step.messages);
    setCurrentStep(nextStepKey);
    showPendingMessages(step.messages, step.next);
  } else {
    goToStep(nextStepKey);
  }
};

const handleSecondaryOptionSelect = (option) => {
  resetInactivityTimer(); // Reset timer on secondary option selection
  const optionMessage = {
    id: Date.now(),
    text: option.text,
    isUser: true,
    time: new Date()
  };

  setSelectedSecondaryOption(option.value);
  setMessages(prev => [...prev, optionMessage]);
  setShowSecondaryOptions(false);
  
  // Reset sequential options state
  setShowOptionsSequentially(false);
  setVisibleOptions([]);
  
  // Show gif immediately, then delay for next question and options
  const gifUrl = currentFlow.secondaryQuestion.gifs[option.value];
  if (gifUrl) {
    const gifMessage = {
      id: Date.now() + 1,
      text: gifUrl,
      isUser: false,
      time: new Date(),
      isGif: true
    };
    setMessages(prev => [...prev, gifMessage]);
  }
  
      // Add delay for next question and options
    setShowThinkingDots(true);
    setTimeout(() => {
      setShowThinkingDots(false);
      const thirdQuestion = {
        id: Date.now() + 2,
        text: currentFlow.thirdQuestion.question,
        isUser: false,
        time: new Date(),
        isFollowUp: true
      };
      setMessages(prev => [...prev, thirdQuestion]);
      setChatState(CHAT_STATES.THIRD_QUESTION);
      setShowThirdOptions(true);
    }, 800); // 0.8 second delay for question and options
};

// Add new handler for third question
const handleThirdOptionSelect = (option) => {
  resetInactivityTimer(); // Reset timer on third option selection
  const optionMessage = {
    id: Date.now(),
    text: option.text,
    isUser: true,
    time: new Date()
  };

  setSelectedThirdOption(option.value);
  setMessages(prev => [...prev, optionMessage]);
  setShowThirdOptions(false);
  
  // Reset sequential options state
  setShowOptionsSequentially(false);
  setVisibleOptions([]);
  
  // Add delay for next question and options
  setShowThinkingDots(true);
  setTimeout(() => {
    setShowThinkingDots(false);
    const fourthQuestion = {
      id: Date.now() + 1,
      text: currentFlow.fourthQuestion.question,
      isUser: false,
      time: new Date(),
      isFollowUp: true
    };
    setMessages(prev => [...prev, fourthQuestion]);
    setChatState(CHAT_STATES.FOURTH_QUESTION);
    setShowFourthOptions(true);
  }, 800); // 0.8 second delay for question and options
};

// Add new handler for fourth question
const handleFourthOptionSelect = (option) => {
  resetInactivityTimer(); // Reset timer on fourth option selection
  const optionMessage = {
    id: Date.now(),
    text: option.text,
    isUser: true,
    time: new Date()
  };

  setSelectedFourthOption(option.value);
  setMessages(prev => [...prev, optionMessage]);
  setShowFourthOptions(false);
  
  // Reset sequential options state
  setShowOptionsSequentially(false);
  setVisibleOptions([]);
  
  // Add delay for elaboration prompt or final messages
  setShowThinkingDots(true);
  setTimeout(() => {
    setShowThinkingDots(false);
    // If user selects 'No, I prefer to keep it private', skip elaboration and show final messages
    if (option.value === 'Keep private') {
      saveChatResponse(); // Save the response before showing final messages
      showFinalMessages();
      return;
    }
    const elaborationPrompt = {
      id: Date.now() + 1,
      text: "Please elaborate yourself .",
      isUser: false,
      time: new Date()
    };
    setMessages(prev => [...prev, elaborationPrompt]);
    setChatState(CHAT_STATES.ELABORATION);
  }, 800); // 0.8 second delay for elaboration prompt
};

  const showFinalMessages = async () => {
    console.log('[DEBUG] Entered showFinalMessages'); // Debug log
    console.log('[DEBUG] Final qaPairs before saving:', qaPairs);
    
    try {
      // Set chat state to completed first
      setChatState(CHAT_STATES.THANK_YOU);
      
      // Store conversation summary in Firestore
      const chatQAObject = {};
      qaPairs.forEach(pair => {
        if (pair.question && pair.answer) {
          chatQAObject[pair.question] = pair.answer;
        }
      });
      console.log('[DEBUG] Final chatQAObject to save:', chatQAObject);
      const summaryData = {
        employeeId: loggedInEmployeeId,
        mood: selectedMood,
        timestamp: new Date(),
        chat: chatQAObject
      };
      
      await addDoc(collection(db, 'chatResponses'), summaryData);
      console.log('Conversation summary saved to Firestore');
      
      // Delete incomplete chat since conversation is completed
      await deleteIncompleteChat();
      console.log('Incomplete chat deleted after completion');
      
      // Show in-app end-of-chat prompt instead of native alerts
      setShowEndPopup(true);
    } catch (error) {
      console.error('Error saving conversation summary:', error);
      if (Platform.OS === 'web') {
        window.alert('Error saving feedback. Please try again.');
      } else {
        Alert.alert('Error', 'Error saving feedback. Please try again.');
      }
    }
  };

  const showPendingMessages = (messagesArr, nextStep) => {
    if (!messagesArr || messagesArr.length === 0) {
      if (nextStep) {
        if (nextStep === 'end') {
          showFinalMessages();
        } else {
          goToStep(nextStep);
        }
      }
      return;
    }
    console.log('[DEBUG] Entered showPendingMessages');
    messagesArr.forEach((msg, idx) => {
      setTimeout(() => {
        setMessages(prev => [
          ...prev,
          { id: Date.now() + idx, text: msg, isUser: false, time: new Date() }
        ]);
        if (idx === messagesArr.length - 1 && nextStep) {
          setTimeout(() => {
            if (nextStep === 'end') {
              showFinalMessages();
            } else {
              goToStep(nextStep);
            }
          }, 1200);
        }
      }, idx * 1200);
    });
  };

  const handleEditTextSubmit = () => {
    if (!editText.trim()) return;
    resetInactivityTimer(); // Reset timer on edit text submit
    const userMsg = {
      id: Date.now(),
      text: editText,
      isUser: true,
      time: new Date()
    };
    setMessages(prev => [...prev, userMsg]);
    
    // Always update the last Q&A pair with the user's custom input
    setQaPairs(prev => {
      const updatedPairs = [...prev];
      if (updatedPairs.length > 0) {
        const lastPair = updatedPairs[updatedPairs.length - 1];
        lastPair.answer = editText;
      }
      return updatedPairs;
    });
    
    // Save immediately after edit text submission
    saveIncompleteChat();
    
    // saveChatMessage(loggedInEmployeeId, userMsg); // REMOVED
    setShowEditText(false);
    setEditText('');
    if (pendingNextStep) {
      const step = currentFlow[pendingNextStep];
      if (step && step.messages) {
        showPendingMessages(step.messages, step.next);
      } else {
        goToStep(pendingNextStep);
      }
      setPendingNextStep(null);
    }
  };

  const renderMoodSelection = () => {
    if (chatState !== CHAT_STATES.MOOD_SELECTION || selectedMood) return null;
    
    console.log('[MOOD DEBUG] Rendering mood selection, showVideo:', showVideo);
    
    return (
      <View style={styles.moodSelectionContainer}>
        <Text style={styles.sectionTitle}>How are you feeling today?</Text>
        <View style={styles.moodGrid}>
          {MOODS.map((mood) => (
            <TouchableOpacity
              key={mood.id}
              style={[
                styles.moodCard,
                selectedMood === mood.id && styles.selectedMoodCard,
                { borderColor: mood.color }
              ]}
              onPress={() => handleMoodSelect(mood.id)}
              activeOpacity={0.8}
            >
              {useExpoImage ? (
                <ExpoImage 
                  source={mood.gif} 
                  style={styles.moodGif} 
                  contentFit="contain"
                  onError={(error) => {
                    console.log('[MOOD GIF ERROR] ExpoImage failed, falling back to Image', error);
                    setUseExpoImage(false);
                  }}
                  onLoad={() => console.log('[MOOD GIF LOADED]', mood.id)}
                  cachePolicy="memory-disk"
                  priority="high"
                  recyclingKey={`${mood.id}-${gifRefreshKey}`}
                />
              ) : (
                <Image 
                  source={mood.gif} 
                  style={styles.moodGif} 
                  resizeMode="contain"
                  onError={(error) => console.log('[MOOD GIF ERROR] Image also failed', error.nativeEvent)}
                  onLoad={() => console.log('[MOOD GIF LOADED] Image fallback', mood.id)}
                />
              )}
              <Text style={styles.moodLabel}>{mood.label}</Text>
              {selectedMood === mood.id && (
                <View style={[styles.selectionIndicator, { backgroundColor: mood.color }]} />
              )}
            </TouchableOpacity>
          ))}
        </View>
        
        {/* Chat GIF below mood selection */}
        {showVideo && (
          <View style={styles.videoContainer}>
            {!gifLoadError ? (
              <>
                {gifLoading && (
                  <View style={[styles.video, { justifyContent: 'center', alignItems: 'center', backgroundColor: '#f0f0f0' }]}>
                    <Text style={styles.loadingText}>Loading...</Text>
                  </View>
                )}
                {useExpoImage ? (
                  <ExpoImage
                    source={require('../assets/images/chat.gif')}
                    style={[styles.video, { opacity: gifLoading ? 0 : 1 }]}
                    contentFit="contain"
                    onError={(error) => {
                      console.log('[GIF ERROR] ExpoImage failed, falling back to Image', error);
                      setUseExpoImage(false);
                    }}
                    onLoad={() => {
                      console.log('[GIF LOADED] Successfully loaded chat.gif');
                      setGifLoadError(false);
                      setGifLoading(false);
                    }}
                    cachePolicy="memory-disk"
                    priority="high"
                    recyclingKey={`chat-gif-${gifRefreshKey}`}
                  />
                ) : (
                  <Image
                    source={require('../assets/images/chat.gif')}
                    style={[styles.video, { opacity: gifLoading ? 0 : 1 }]}
                    resizeMode="contain"
                    onError={(error) => {
                      console.log('[GIF ERROR] Image also failed', error.nativeEvent);
                      setGifLoadError(true);
                      setGifLoading(false);
                    }}
                    onLoad={() => {
                      console.log('[GIF LOADED] Image fallback loaded chat.gif');
                      setGifLoadError(false);
                      setGifLoading(false);
                    }}
                  />
                )}
              </>
            ) : (
              <View style={[styles.video, { justifyContent: 'center', alignItems: 'center', backgroundColor: '#f8f8f8' }]}>
                <Text style={styles.fallbackText}>Welcome to mDojo! 👋</Text>
                <TouchableOpacity 
                  style={styles.refreshButton}
                  onPress={() => {
                    setGifLoadError(false);
                    setGifLoading(true);
                    refreshGifs();
                  }}
                >
                  <Text style={styles.refreshButtonText}>Retry GIF</Text>
                </TouchableOpacity>
              </View>
            )}
          </View>
        )}
      </View>
    );
  };

  const renderFollowUpOptions = () => {
    if (!showOptions || chatState !== CHAT_STATES.FOLLOW_UP || !selectedMood || !currentFlow) return null;
    
    const scrollLeft = () => {
      followUpScrollRef.current?.scrollTo({ x: 0, animated: true });
    };
    
    const scrollRight = () => {
      followUpScrollRef.current?.scrollToEnd({ animated: true });
    };
    
    return (
      <View>
        <View style={styles.optionsContainer}>
          <ScrollView 
            ref={followUpScrollRef}
            horizontal 
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={styles.optionsScrollContent}
          >
            {currentFlow.initialQuestion.options.map((option, index) => (
              <TouchableOpacity
                key={index}
                style={[
                  styles.optionButton,
                  { backgroundColor: '#E31937' }
                ]}
                onPress={() => handleOptionSelect(option.text, option.nextStepKey)}
              >
                <EmojiText style={styles.optionText} emojiSize={28}>{option.emoji ? option.emoji + ' ' + option.text : option.text}</EmojiText>
              </TouchableOpacity>
            ))}
          </ScrollView>
        </View>
        <View style={styles.scrollArrowsContainer}>
          <TouchableOpacity 
            style={styles.scrollArrowButton} 
            onPress={scrollLeft}
          >
            <MaterialIcons name="chevron-left" size={24} color="#FFF" />
          </TouchableOpacity>
          <TouchableOpacity 
            style={styles.scrollArrowButton} 
            onPress={scrollRight}
          >
            <MaterialIcons name="chevron-right" size={24} color="#FFF" />
          </TouchableOpacity>
        </View>
      </View>
    );
  };

  const renderSecondaryOptions = () => {
    if (!showSecondaryOptions || chatState !== CHAT_STATES.SECONDARY_QUESTION || !selectedMood || !currentFlow) return null;
    
    const scrollLeft = () => {
      secondaryScrollRef.current?.scrollTo({ x: 0, animated: true });
    };
    
    const scrollRight = () => {
      secondaryScrollRef.current?.scrollToEnd({ animated: true });
    };
    
    return (
      <View>
        <View style={styles.optionsContainer}>
          <ScrollView 
            ref={secondaryScrollRef}
            horizontal 
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={styles.optionsScrollContent}
          >
            {currentFlow.secondaryQuestion.options.map((option, index) => (
              <TouchableOpacity
                key={index}
                style={[
                  styles.optionButton,
                  { backgroundColor: '#E31937' }
                ]}
                onPress={() => handleSecondaryOptionSelect(option)}
              >
                <EmojiText style={styles.optionText} emojiSize={28}>{option.text}</EmojiText>
              </TouchableOpacity>
            ))}
          </ScrollView>
        </View>
        <View style={styles.scrollArrowsContainer}>
          <TouchableOpacity 
            style={styles.scrollArrowButton} 
            onPress={scrollLeft}
          >
            <MaterialIcons name="chevron-left" size={24} color="#FFF" />
          </TouchableOpacity>
          <TouchableOpacity 
            style={styles.scrollArrowButton} 
            onPress={scrollRight}
          >
            <MaterialIcons name="chevron-right" size={24} color="#FFF" />
          </TouchableOpacity>
        </View>
      </View>
    );
  };
  const renderThirdOptions = () => {
  if (!showThirdOptions || chatState !== CHAT_STATES.THIRD_QUESTION || !currentFlow?.thirdQuestion) return null;
  
  const scrollLeft = () => {
    thirdScrollRef.current?.scrollTo({ x: 0, animated: true });
  };
  
  const scrollRight = () => {
    thirdScrollRef.current?.scrollToEnd({ animated: true });
  };
  
  return (
    <View>
      <View style={styles.optionsContainer}>
        <ScrollView 
          ref={thirdScrollRef}
          horizontal 
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={styles.optionsScrollContent}
        >
          {currentFlow.thirdQuestion.options.map((option, index) => (
            <TouchableOpacity
              key={index}
              style={styles.optionButton}
                              onPress={() => handleThirdOptionSelect(option)}
              >
                <EmojiText style={styles.optionText} emojiSize={28}>{option.text}</EmojiText>
              </TouchableOpacity>
          ))}
        </ScrollView>
      </View>
      <View style={styles.scrollArrowsContainer}>
        <TouchableOpacity 
          style={styles.scrollArrowButton} 
          onPress={scrollLeft}
        >
          <MaterialIcons name="chevron-left" size={24} color="#FFF" />
        </TouchableOpacity>
        <TouchableOpacity 
          style={styles.scrollArrowButton} 
          onPress={scrollRight}
        >
          <MaterialIcons name="chevron-right" size={24} color="#FFF" />
        </TouchableOpacity>
      </View>
    </View>
  );
};

const renderFourthOptions = () => {
  if (!showFourthOptions || chatState !== CHAT_STATES.FOURTH_QUESTION || !currentFlow?.fourthQuestion) return null;
  
  const scrollLeft = () => {
    fourthScrollRef.current?.scrollTo({ x: 0, animated: true });
  };
  
  const scrollRight = () => {
    fourthScrollRef.current?.scrollToEnd({ animated: true });
  };
  
  return (
    <View>
      <View style={styles.optionsContainer}>
        <ScrollView 
          ref={fourthScrollRef}
          horizontal 
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={styles.optionsScrollContent}
        >
          {currentFlow.fourthQuestion.options.map((option, index) => (
            <TouchableOpacity
              key={index}
              style={styles.optionButton}
                              onPress={() => handleFourthOptionSelect(option)}
              >
                <EmojiText style={styles.optionText} emojiSize={28}>{option.text}</EmojiText>
              </TouchableOpacity>
          ))}
        </ScrollView>
      </View>
      <View style={styles.scrollArrowsContainer}>
        <TouchableOpacity 
          style={styles.scrollArrowButton} 
          onPress={scrollLeft}
        >
          <MaterialIcons name="chevron-left" size={24} color="#FFF" />
        </TouchableOpacity>
        <TouchableOpacity 
          style={styles.scrollArrowButton} 
          onPress={scrollRight}
        >
          <MaterialIcons name="chevron-right" size={24} color="#FFF" />
        </TouchableOpacity>
      </View>
    </View>
  );
};

const renderCurrentStep = () => {
  if (!currentFlow || !currentStep) return null;
  const step = currentFlow[currentStep];
  if (!step) return null;
  if (step.question_edit && showEditText) {
    return (
      <View style={[styles.optionsContainer, { flexDirection: 'row', alignItems: 'center' }]}> {/* Make row */}
        <TextInput
          ref={editTextInputRef}
          style={[styles.input, { flex: 1, marginRight: 8 }]}
          value={editText}
          onChangeText={(text) => {
            // Check if the original question_edit was empty or just whitespace
            const originalText = editTextPlaceholder || '';
            const isOriginalEmpty = !originalText.trim();
            
            if (isOriginalEmpty) {
              // If original was empty, allow free text input
              setEditText(text);
            } else {
              // If original has content, use bracket editing logic
              const newText = handleBracketEdit(editText, text);
              setEditText(newText);
            }
          }}
          placeholder={editTextPlaceholder}
          multiline
          onFocus={() => {
            if (scrollViewRef.current) {
              scrollViewRef.current.scrollToEnd({ animated: true });
            }
          }}
        />
        <TouchableOpacity
          style={[styles.sendButton, !editText.trim() && styles.sendButtonDisabled]}
          onPress={handleEditTextSubmit}
          disabled={!editText.trim()}
        >
          <MaterialIcons name="send" size={22} color="#fff" style={styles.sendIcon} />
        </TouchableOpacity>
      </View>
    );
  }
  if (step.options) {
    return (
      <View style={{ flexDirection: 'row', flexWrap: 'wrap', alignItems: 'flex-start', justifyContent: 'flex-start' }}>
        {visibleOptions.map((option, index) => (
          <TouchableOpacity
            key={option.text}
            style={[
              styles.optionButton, 
              { 
                alignSelf: 'flex-start', 
                marginRight: 12, 
                marginBottom: 12, 
                minWidth: undefined, 
                width: undefined, 
                maxWidth: '90%',
                opacity: 1,
                transform: [{ scale: 1 }]
              }
            ]}
            onPress={() => {
              // Prevent multiple rapid selections
              const isProcessing = optionTimeoutsRef.current.length > 0;
              if (isProcessing) {
                // Clear pending timeouts and disable sequential animation
                optionTimeoutsRef.current.forEach(timeoutId => clearTimeout(timeoutId));
                optionTimeoutsRef.current = [];
              }
              handleOptionSelect(option.text, option.nextStepKey);
            }}
          >
            <EmojiText style={styles.optionText} emojiSize={28}>{option.text}</EmojiText>
          </TouchableOpacity>
        ))}
      </View>
    );
  }
};
    const renderInputField = () => {
      if (chatState === CHAT_STATES.ELABORATION) {
        return (
          <TextInput
            style={styles.input}
            value={elaboration}
            onChangeText={setElaboration}
            placeholder='Please elaborate on your choices...'
            placeholderTextColor="#999"
            multiline
            onSubmitEditing={() => !isSendDisabled() && handleSend()}
            returnKeyType="send"
            onFocus={() => {
              if (scrollViewRef.current) {
                scrollViewRef.current.scrollToEnd({ animated: true });
              }
            }}
          />
        );
      }
      return null;
    };
  // ... (keep all your other existing functions like showMoodSelection, showInitialQuestion, 
  // handleOptionSelect, handleSecondaryOptionSelect, showFinalMessages, etc.)

  // ... (keep all your existing render functions like renderMoodSelection, 
  // renderFollowUpOptions, renderSecondaryOptions, renderInputField)

  // Don't render until fonts are loaded
  if (!fontsLoaded) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#FF5A5F' }}>
        <Text style={{ color: '#FFF', fontSize: 18, fontFamily: 'System' }}>Loading...</Text>
      </View>
    );
  }

  return (
    <KeyboardAvoidingView 
      style={{ flex: 1 }} 
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 0 : 20}
    >
      <SafeAreaView style={styles.safeArea}>
        <View style={styles.background}>
          <View style={styles.chatContainer}>
            <View style={styles.chatHeader}>
              <Image 
                source={require('../assets/mdojo.jpg')}
                style={styles.chatHeaderLogo}
                resizeMode="contain"
              />
            </View>
            
            <ScrollView 
              ref={scrollViewRef}
              contentContainerStyle={styles.messagesContainer}
              style={styles.messagesScrollView}
              keyboardShouldPersistTaps="handled"
              showsVerticalScrollIndicator={false}
            >
            {isTyping && (
            <View style={styles.typingIndicator}>
              <View style={styles.typingDot} />
              <View style={[styles.typingDot, {marginHorizontal: 4}]} />
              <View style={styles.typingDot} />
            </View>
          )}
            {showThinkingDots && (
            <View style={styles.thinkingIndicator}>
              <Text style={styles.thinkingText}>Thinking</Text>
              <View style={styles.thinkingDots}>
                <View style={styles.thinkingDot} />
                <View style={[styles.thinkingDot, {marginHorizontal: 2}]} />
                <View style={styles.thinkingDot} />
              </View>
            </View>
          )}

              {messages
                .filter(msg => typeof msg.text === 'string' && msg.text.trim() !== '')
                .map((msg) => (
                <Animated.View 
                  key={msg.id} 
                  style={[
                    styles.messageBubble, 
                    msg.isUser ? styles.userBubble : styles.botBubble,
                    { opacity: fadeAnim }
                  ]}
                >
                  {msg.isGif ? (
                    useExpoImage ? (
                      <ExpoImage 
                        source={{ uri: msg.text }}
                        style={styles.gifImage}
                        contentFit="contain"
                        cachePolicy="memory-disk"
                        priority="high"
                        recyclingKey={`msg-gif-${msg.id}-${gifRefreshKey}`}
                        onError={(error) => {
                          console.log('[MESSAGE GIF ERROR] ExpoImage failed, falling back to Image', error);
                          setUseExpoImage(false);
                        }}
                      />
                    ) : (
                      <Image 
                        source={{ uri: msg.text }}
                        style={styles.gifImage}
                        resizeMode="contain"
                        onError={(error) => console.log('[MESSAGE GIF ERROR] Image also failed', error.nativeEvent)}
                      />
                    )
                  ) : msg.isWelcomeGif ? (
                    useExpoImage ? (
                      <ExpoImage 
                        source={msg.gifSource}
                        style={styles.gifImage}
                        contentFit="contain"
                        cachePolicy="memory-disk"
                        priority="high"
                        recyclingKey={`welcome-gif-${msg.id}-${gifRefreshKey}`}
                        onError={(error) => {
                          console.log('[WELCOME GIF ERROR] ExpoImage failed, falling back to Image', error);
                          setUseExpoImage(false);
                        }}
                      />
                    ) : (
                      <Image 
                        source={msg.gifSource}
                        style={styles.gifImage}
                        resizeMode="contain"
                        onError={(error) => console.log('[WELCOME GIF ERROR] Image also failed', error.nativeEvent)}
                      />
                    )
                  ) : (
                    <EmojiText style={msg.isUser ? styles.userText : (msg.isWelcomeGif || msg.isWelcomeText) ? styles.welcomeText : styles.botText} emojiSize={32}>
                      {msg.text}
                    </EmojiText>
                  )}
                  <Text style={[
                    styles.timeText,
                    msg.isUser ? styles.userTimeText : {}
                  ]}>
                    {msg.time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                  </Text>
                </Animated.View>
              ))}
              {renderMoodSelection()}
              {renderCurrentStep()}
              {renderFollowUpOptions()}
              {renderSecondaryOptions()}
              {renderThirdOptions()}
              {renderFourthOptions()}
            </ScrollView>

            {(chatState === CHAT_STATES.ELABORATION) && (
              <View style={styles.inputContainer}>
                {renderInputField()}
                <TouchableOpacity 
                  onPress={handleSend} 
                  style={[
                    styles.sendButton,
                    isSendDisabled() && styles.sendButtonDisabled
                  ]}
                  disabled={isSendDisabled()}
                >
                  <MaterialIcons 
                    name="send" 
                    size={22} 
                    color="#fff" 
                    style={styles.sendIcon}
                  />
                </TouchableOpacity>
              </View>
            )}

            {/* End of conversation popup */}
            <Modal
              visible={showEndPopup}
              transparent
              animationType="fade"
              onRequestClose={() => setShowEndPopup(false)}
            >
              <View style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.4)', justifyContent: 'center', alignItems: 'center' }}>
                <View style={{ backgroundColor: '#fff', borderRadius: 20, padding: 32, alignItems: 'center', maxWidth: 320 }}>
                  <Text style={{ fontSize: 20, fontWeight: 'bold', marginBottom: 16, color: '#E31937' }}>Thank you!</Text>
                  <Text style={{ fontSize: 16, color: '#444', marginBottom: 24, textAlign: 'center' }}>
                    Your feedback has been submitted. We appreciate your time!
                  </Text>
                  <TouchableOpacity
                    onPress={() => { setShowEndPopup(false); router.replace('/login'); }}
                    style={{ backgroundColor: '#E31937', borderRadius: 16, paddingVertical: 10, paddingHorizontal: 32 }}
                  >
                    <Text style={{ color: '#fff', fontSize: 16, fontWeight: '600' }}>Close</Text>
                  </TouchableOpacity>
                </View>
              </View>
            </Modal>

                       {/* Inactivity prompt */}
             {showInactivityPrompt && (
               <Modal
                 visible={showInactivityPrompt}
                 transparent
                 animationType="fade"
                 onRequestClose={handleInactivityPromptTap}
               >
                 <TouchableOpacity
                   style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: 'rgba(0,0,0,0.5)' }}
                   onPress={handleInactivityPromptTap}
                 >
                   <View style={{ backgroundColor: '#fff', borderRadius: 15, padding: 20, alignItems: 'center' }}>
                     <Text style={{ fontSize: 18, fontWeight: 'bold', color: '#E31937', marginBottom: 10 }}>
                       Still there?
                     </Text>
                     <Text style={{ fontSize: 14, color: '#666', textAlign: 'center', marginBottom: 20 }}>
                       Take your time — just tap when ready.
                     </Text>
                     <TouchableOpacity
                       onPress={handleInactivityPromptTap}
                       style={{ backgroundColor: '#E31937', borderRadius: 10, paddingVertical: 10, paddingHorizontal: 20 }}
                     >
                       <Text style={{ color: '#fff', fontSize: 16, fontWeight: '600' }}>
                         Continue
                       </Text>
                     </TouchableOpacity>
                   </View>
                 </TouchableOpacity>
               </Modal>
             )}
          </View>
        </View>
      </SafeAreaView>
    </KeyboardAvoidingView>
  );
};

const saveChatMessage = async (employeeId, messageObj) => {
  await addDoc(collection(db, 'chatResponses'), {
    employeeId,
    ...messageObj,
    timestamp: serverTimestamp(),
  });
};


// ... (keep all your existing styles)

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: '#FF5A5F', // More vibrant red
  },
  background: {
    flex: 1,
    backgroundColor: '#FF5A5F',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 10,
  },
  chatContainer: {
    width: '100%',
    maxWidth: 1000,
    height: height * 0.92,
    backgroundColor: '#FFF',
    borderRadius: 24,
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 10 },
    shadowOpacity: 0.2,
    shadowRadius: 20,
    elevation: 10,
    borderWidth: 1,
    borderColor: 'rgba(255,255,255,0.2)',
  },
  chatHeader: {
    backgroundColor: '#f5f5f5',
    padding: 0,
    justifyContent: 'center',
    alignItems: 'center',
    borderBottomLeftRadius: 20,
    borderBottomRightRadius: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
    position: 'relative',
  },

  chatHeaderLogo: {
    width: 1020,
    height: 90,
    borderRadius: 10,
    backgroundColor: 'transparent',
  },


  messagesScrollView: {
    flex: 1,
    backgroundColor: '#FAFAFA',
  },
  messagesContainer: {
    padding: 16,
    paddingBottom: 20,
  },
  messageBubble: {
    maxWidth: '80%',
    padding: 20,
    paddingTop: 22,
    paddingBottom: 22,
    borderRadius: 18,
    marginBottom: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 4,
    elevation: 2,
    minHeight: 60,
    justifyContent: 'center',
  },
  botBubble: {
    backgroundColor: '#FFF',
    borderTopLeftRadius: 4,
    borderBottomRightRadius: 18,
    borderTopRightRadius: 18,
    alignSelf: 'flex-start',
    borderWidth: 1,
    borderColor: '#EEE',
  },
  userBubble: {
    backgroundColor: '#FF5A5F',
    borderTopLeftRadius: 18,
    borderBottomLeftRadius: 18,
    borderBottomRightRadius: 4,
    alignSelf: 'flex-end',
  },
  botText: {
    color: '#333',
    fontSize: 16,
    lineHeight: 24,
    includeFontPadding: false,
    textAlignVertical: 'center',
    fontFamily: Platform.OS === 'ios' ? 'Arial' : 'sans-serif',
  },
  welcomeText: {
    color: '#333',
    fontSize: 22,
    lineHeight: 28,
    fontWeight: 'bold',
    includeFontPadding: false,
    textAlignVertical: 'center',
    fontFamily: Platform.OS === 'ios' ? 'Arial' : 'sans-serif',
  },
  // Mood Selection Styles
  moodSelectionContainer: {
    marginBottom: 20,
    width: '100%',
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#333',
    marginBottom: 20,
    textAlign: 'center',
  },
  moodGrid: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    flexWrap: 'wrap',
    marginBottom: 20,
  },
  moodCard: {
    width: '30%',
    aspectRatio: 1,
    backgroundColor: '#FFF',
    borderRadius: 16,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 10,
    marginBottom: 15,
    borderWidth: 2,
    borderColor: '#EEE',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 4,
    elevation: 2,
  },
  selectedMoodCard: {
    borderColor: '#E31937',
    backgroundColor: '#FFF5F6',
  },
  moodGif: {
    width: 75,
    height: 70,
    marginBottom: 12,
  },
  moodLabel: {
    fontSize: 14,
    fontWeight: '500',
    color: '#333',
    marginTop: 8,
    textAlign: 'center',
  },
  selectionIndicator: {
    position: 'absolute',
    bottom: -6,
    width: 12,
    height: 12,
    borderRadius: 6,
  },
  debugText: {
    display: 'none',
    fontSize: 12,
    color: '#999',
    textAlign: 'center',
    marginBottom: 10,
  },
  userText: {
    color: '#FFF',
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '500',
    includeFontPadding: false,
    textAlignVertical: 'center',
    fontFamily: Platform.OS === 'ios' ? 'Arial' : 'sans-serif',
  },
  timeText: {
    fontSize: 10,
    color: '#999',
    marginTop: 6,
    textAlign: 'right',
  },
  userTimeText: {
    color: 'rgba(255, 255, 255, 0.7)',
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    paddingBottom: 20,
    backgroundColor: '#FFF',
    borderTopWidth: 1,
    borderTopColor: '#EEE',
  },
  input: {
    flex: 1,
    maxHeight: 120,
    minHeight: 50,
    borderWidth: 1,
    borderColor: '#DDD',
    borderRadius: 25,
    paddingHorizontal: 18,
    paddingVertical: 12,
    fontSize: 16,
    backgroundColor: '#F8F8F8',
    textAlignVertical: 'center',
    includeFontPadding: false,
    color: '#333',
    fontFamily: 'SpaceMono-Regular',
  },
  employeeIdInput: {
    fontFamily: 'monospace',
    letterSpacing: 1,
  },
  sendButton: {
    marginLeft: 10,
    justifyContent: 'center',
    alignItems: 'center',
    width: 50,
    height: 50,
    borderRadius: 25,
    backgroundColor: '#FF5A5F',
    shadowColor: '#FF5A5F',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 4,
  },
  sendIcon: {
    marginLeft: 3,
  },
  sendButtonDisabled: {
    backgroundColor: '#CCC',
    shadowOpacity: 0,
    elevation: 0,
  },
  moodSelectionContainer: {
    backgroundColor: '#FFF',
    borderRadius: 20,
    margin: 16,
    padding: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 6 },
    shadowOpacity: 0.1,
    shadowRadius: 12,
    elevation: 5,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: '#444',
    marginBottom: 20,
    textAlign: 'center',
    fontFamily: 'SpaceMono-Regular',
  },
  moodGrid: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    flexWrap: 'wrap',
    marginHorizontal: -4,
  },
  moodCard: {
    width: '31%',
    aspectRatio: 1,
    backgroundColor: '#FFF',
    borderRadius: 16,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 6,
    elevation: 4,
    position: 'relative',
    overflow: 'hidden',
    transform: [{ scale: 1 }],
  },
  selectedMoodCard: {
    transform: [{ scale: 1.05 }],
    elevation: 8,
    shadowRadius: 10,
    shadowOpacity: 0.15,
  },
  moodEmoji: {
    fontSize: 36,
    marginBottom: 8,
  },
  moodLabel: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#444',
    textAlign: 'center',
    fontFamily: 'SpaceMono-Regular',
  },
  selectionIndicator: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    height: 6,
  },
  optionsContainer: {
    backgroundColor: '#FFF',
    borderRadius: 16,
    marginHorizontal: 16,
    marginBottom: 12,
    padding: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 3,
    position: 'relative',
  },
  optionsScrollContent: {
    paddingHorizontal: 8,
  },
  optionButton: {
    paddingHorizontal: 18,
    paddingVertical: 12,
    borderRadius: 24,
    marginRight: 12,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    minWidth: 140,
    backgroundColor: '#FF5A5F',
    shadowColor: '#FF5A5F',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 4,
    elevation: 2,
  },
  optionText: {
    color: '#FFF',
    fontSize: 15,
    marginLeft: 8,
    fontWeight: '500',
    fontFamily: 'SpaceMono-Regular',
  },
  optionEmoji: {
    fontSize: 28,
    color: '#FFF',
    includeFontPadding: false,
    textAlignVertical: 'center',
  },
  gifImage: {
    width: 220,
    height: 160,
    borderRadius: 12,
    marginVertical: 8,
  },
  typingIndicator: {
  flexDirection: 'row',
  alignSelf: 'flex-start',
  marginBottom: 12,
  marginLeft: 16,
},
typingDot: {
  width: 8,
  height: 8,
  borderRadius: 4,
  backgroundColor: '#CCC',
},
thinkingIndicator: {
  flexDirection: 'row',
  alignSelf: 'flex-start',
  marginBottom: 12,
  marginLeft: 16,
  alignItems: 'center',
  backgroundColor: '#f0f0f0',
  paddingHorizontal: 12,
  paddingVertical: 8,
  borderRadius: 16,
},
  thinkingText: {
    fontSize: 14,
    color: '#666',
    marginRight: 8,
    fontStyle: 'italic',
    fontFamily: 'SpaceMono-Regular',
  },
thinkingDots: {
  flexDirection: 'row',
  alignItems: 'center',
},
thinkingDot: {
  width: 6,
  height: 6,
  borderRadius: 3,
  backgroundColor: '#E31937',
  opacity: 0.7,
},
mahendraContainer: {
  position: 'absolute',
  top: 40,
  left: 20,
  zIndex: 10,
},
  mahendraText: {
    fontSize: 28,
    fontWeight: 'bold',
    color: 'rgb(255, 255, 255)',
    letterSpacing: 1,
    textTransform: 'uppercase',
    fontFamily: 'SpaceMono-Regular',
  },
mlogo: {
  position: 'absolute',
  top: 40,
  right: 20,
  zIndex: 10,
},
mahendra: {
  width: 120,
  height: 40,
},
scrollArrowLeft: {
  position: 'absolute',
  left: 0,
  top: 0,
  bottom: 0,
  width: 30,
  justifyContent: 'center',
  alignItems: 'center',
  zIndex: 1,
  backgroundColor: 'rgba(227, 25, 55, 0.7)',
  borderTopLeftRadius: 16,
  borderBottomLeftRadius: 16,
},
scrollArrowRight: {
  position: 'absolute',
  right: 0,
  top: 0,
  bottom: 0,
  width: 30,
  justifyContent: 'center',
  alignItems: 'center',
  zIndex: 1,
  backgroundColor: 'rgba(227, 25, 55, 0.7)',
  borderTopRightRadius: 16,
  borderBottomRightRadius: 16,
},
scrollArrowsContainer: {
  flexDirection: 'row',
  justifyContent: 'center',
  alignItems: 'center',
  marginTop: 8,
  marginHorizontal: 16,
  gap: 12,
},
scrollArrowButton: {
  backgroundColor: 'rgba(227, 25, 55, 0.8)',
  borderRadius: 20,
  width: 40,
  height: 40,
  justifyContent: 'center',
  alignItems: 'center',
  shadowColor: '#000',
  shadowOffset: { width: 0, height: 2 },
  shadowOpacity: 0.2,
  shadowRadius: 4,
  elevation: 3,
},
  videoContainer: {
    width: '100%',
    maxWidth: 400,
    height: 200,
    marginTop: 30,
    marginHorizontal: 0,
    borderRadius: 15,
    overflow: 'hidden',
    backgroundColor: 'transparent',
    position: 'relative',
    alignSelf: 'center',
  },
  video: {
    width: '100%',
    height: '100%',
  },
  fallbackText: {
    fontSize: 18,
    fontWeight: '600',
    color: '#E31937',
    textAlign: 'center',
    fontFamily: 'SpaceMono-Regular',
  },
  loadingText: {
    fontSize: 16,
    color: '#666',
    fontFamily: 'SpaceMono-Regular',
  },
  refreshButton: {
    backgroundColor: '#E31937',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    marginTop: 10,
  },
  refreshButtonText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: '600',
    fontFamily: 'SpaceMono-Regular',
  },
videoDebugText: {
  position: 'absolute',
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  backgroundColor: 'rgba(0,0,0,0.5)',
  color: '#fff',
  fontSize: 16,
  fontWeight: 'bold',
  textAlign: 'center',
  paddingTop: 10,
},
  debugText: {
    fontSize: 12,
    color: '#999',
    marginBottom: 10,
    textAlign: 'center',
    fontFamily: 'SpaceMono-Regular',
  },
});

export default ChatScreen;